<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja" xml:lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="PureBuilder Simply WP Importer" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
    <meta name="author" content="Masaki Haruka" />
    <meta name="date" content="2015-04-08T00:00:00+09:00" />
    <meta name="dcterms.date" content="2015-04-08T00:00:00+09:00" />
    <title>ネストされた構造のためのPureDocのTOC展開 - Chienomi</title>
    <style type="text/css">article {
max-width: 1080px;
margin: auto;
}</style>
  </head>
  <body>

    <section id="ContentContainer">
      <header id="MainHeader"><a href="/"><h1>Chienomi</h1></a></header>
      <section id="ArticleBox">
        <header id="ArticleTitle"><h1>ネストされた構造のためのPureDocのTOC展開</h1></header>
        <article id="MainArticle">
<h3 id="ネストtoc機能">ネストTOC機能</h3>
<p>文書からTOCを作る上で、やはり構造的にネストしたいことはあると思う。 最もポピュラーなのは、<code>ul</code>をネストさせることだろう。</p>
<p>だが、難しいのは、例えば最初に<code>h4</code>が来て、次に<code>h2</code>が来て、などということがありうるのだ。そして、<code>h3</code>は存在しないかもしれない。</p>
<p>間の全てのレベルが存在することにするのか。順に礼儀正しく登場すると仮定していいのか。</p>
<p>結局だが、汎用性のある仕様として次のようにした。</p>
<ul>
<li>最低レベルはオフセットかまたは実際に使われた最も大きいヘッダーに基づく（数え方としてはmin）</li>
<li>レベルの変遷に応じて変遷分<code>proc4open</code>や<code>proc4close</code>を呼ぶ。例えば<code>-&gt;(l, ol) { &quot;&lt;ul&gt;&quot; }</code>のように書く。</li>
<li><p>当該レベルまではopen/closeした後は<code>proc4each</code>を呼ぶ。</p>
<p>def nest_expand(proc4open, proc4close, proc4each, offset=nil) result = [] mi = self.min { |i| i.level } or return nil mi = mi.level</p>
<pre><code> if ! offset.respond_to?(:to_int) || offset &gt; ( mi - 1 )
         offset = mi - 1
 end

 cur = offset

 self.each do |i|
     if i.level &gt; cur
         (i.level - cur ).times {|n| result &lt;&lt; proc4open.call( ( i.level - (i.level - cur - 1 - n) ), ( i.level - offset - (i.level - cur - 1 - n) )) }
     elsif i.level &lt; cur
         result &lt;&lt; (cur - i.level).times {|n| proc4close.call( (cur - n), ( cur - n - offset ) ) }
     end

     result &lt;&lt; proc4each.call(i.level, (i.level - offset), i.title)

     cur = i.level
 end

 result.join</code></pre>
<p>end</p></li>
</ul>
<p>eRubyでは内部のメソッドが<code>puts</code>すればいいような言い方をされることが多いが、それは先に出力されてしまっていたので、置換できるようにするために一旦配列に格納した。</p>
<p>テンプレート側の記述量が多く、また直感的でないというデメリットはあるが、なんとかうまく処理できた。</p>
<h3 id="instance_evalと定数">instance_evalと定数</h3>
<p>しかし、むしろ苦戦したのは、ProfileでTOCを含めることだった。</p>
<p>Profileは基本的にそれ自体がPureDocを拡張したRubyコードである。</p>
<p>文章としてヘッダーを含めているわけでもないので、TOCを作るためのとっかかりがないのだ。</p>
<p>そこで結局は</p>
<ul>
<li>テンプレート側でテーブル手前にリンクを貼る</li>
<li>profileであとから各カテゴリをヘッダとして登録する</li>
</ul>
<p>という方法を取ったのだが、意外な理由でうまくいなかった。 というのは、</p>
<p>「<code>instance_eval</code>で評価した場合、そのコンテキストが認識する定数にアクセスできない」</p>
<p>のだ。PureDocはソースを<code>Object#instance_eval</code>を使って解析するため、この問題にひっかかっってヘッダーの登録ができなかった。</p>
<p>そこで、PureDocに登録用のメソッドを追加することとなった。</p>
<p>簡単に書いているが、profileは整頓されていない部分が多く、結構大変だった。</p>

<!-- PBSEARCH_RESULT -->
        </article>
    </section>
    <footer id="InfoFooter">
      <ul>
        <li>© Masaki Haruka 2003.</li>
        <li>Generated by <a href="https://gitlab.com/reasonset/pbsimply-wpimporter">PureBuilder Simply WP Importer</a></li>
      </ul>
    </footer>
  </body>
</html>
