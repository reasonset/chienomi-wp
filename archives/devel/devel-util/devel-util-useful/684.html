<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja" xml:lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="PureBuilder Simply WP Importer" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
    <meta name="author" content="Masaki Haruka" />
    <meta name="date" content="2015-08-05T00:00:00+09:00" />
    <meta name="dcterms.date" content="2015-08-05T00:00:00+09:00" />
    <title>PureBuilder2 (2) - Chienomi</title>
    <style type="text/css">article {
max-width: 1080px;
margin: auto;
}</style>
  </head>
  <body>

    <section id="ContentContainer">
      <header id="MainHeader"><a href="/"><h1>Chienomi</h1></a></header>
      <section id="ArticleBox">
        <header id="ArticleTitle"><h1>PureBuilder2 (2)</h1></header>
        <article id="MainArticle">
<h3 id="kramdown拡張でpdocオブジェクト化">Kramdown拡張でPDocオブジェクト化</h3>
<p>PureBuilder2はもともと思っていたよりもかなり大規模なものになっているが、MarkdownオブジェクトをPureDocと同様に扱えるようにする、というのが今回のテーマ。</p>
<p>例えばテンプレートで</p>
<pre><code>DOC.body</code></pre>
<p>のように書かれている場合がある。この場合は当然、HTMLへ変換したのであればHTML文字列が得られなくてはいけない。 また、</p>
<pre><code>DOC.meta[&quot;title&quot;]</code></pre>
<p>のようにもアクセスできる。 それだけなら単にアクセッサを拡張してやればいい話なのだが、PureDocオブジェクトはTOCのためのループ機能が組み込まれている。 これにより章立てをループさせることができ、簡単に任意の形式でTOCを組める。 これはどうしてもパース時に情報を取らなくてはいけない。</p>
<p>もし、HTMLに出力するものである、というのであれば、単純に結果のHTMLをパースして取得する方法もある。 だが、KramdownライブラリはLaTeXとPDFをサポートする。PureDocもゆくゆくはLaTeX形式での出力をサポートする予定である。</p>
<p>であれば、やはりKramdownでのMarkdownパース時にTOCを作りたい。</p>
<p>基本的な方針としては、実際に<code>PureDoc</code>オブジェクトを使用する。 これはパーサ/コンバータを含まないベースクラスで、本来は直接このクラスのインスタンスを生成することは想定していなかった。 だが、外側から使用するメソッドは一通り持っており、インターフェイスは揃っている。</p>
<p><code>DOC.body</code>で返すべき<code>@body</code>は<code>DOC.body=</code>を用いて入れ、<code>DOC.meta</code>に関しては<code>PureDoc</code>クラスが持っている機能によってドキュメントから取り込むといったことが可能。 そのため、<code>DOC</code>は<code>PureDoc</code>インスタンスであり、Kramdownの結果は<code>DOC.body=</code>によって入れるだけだ。</p>
<p>だが、<code>DOC.stock_ehader</code>を用いてヘッダを入力し、TOCを生成できるようにしなければいけない。 そこで、Kramdownに手を入れる必要があった。</p>
<p>ソースコードを追っていったが、結局<code>Kramdown::Parser::Kramdown#new_block_el</code>をオーバーライドするのが良いと分かった。 ヘッダを取得するパートはあるが、<code>new_block_el</code>メソッドはメソッド自体が短く、あくまでパース時に各エレメント対して呼ばれるものだ。何のために呼ばれているかを判定する必要もなく、引数を丸々渡すだけで良いため、overrideしやすかった。</p>
<pre><code>require &#39;kramdown&#39;

# Override Kramdown
class Kramdown::Parser::Kramdown

  alias _new_block_el_orig new_block_el
  </code></pre>
<p>def new_block_el(*arg)</p>
<pre><code>   	if arg[-1].kind_of?(Hash)
    
      case arg[0]
      
      # Is Header?
      when :header
        p arg[-1][:level]
        p arg[-1][:raw_text]
      end
      
    end
    
    _new_block_el_orig(*arg)</code></pre>
<p>end end</p>
<pre><code>p Kramdown::Document.new(ARGF.read).to_html</code></pre>
<p>というテストコードを書き、実際に動作することを確認、<code>when :header</code>部分を</p>
<pre><code>::DOC.stock_header(arg[-1][:level], arg[-1][:raw_text])</code></pre>
<p>と書き換えた。</p>
<p>KramdownはPure Rubyで書かれているため、扱いやすいし、ソースコードを書くのも楽だ。 だが、できればサブクラス化するなど、もう少しスマートな方法でできればよかったな、と思う。クラスが細かく分割されて連携しているため、置き換えるのはかなり難しいと判断した。</p>
<p>Kramdownは非常に良いライブラリなのは間違いない。</p>
<h3 id="forkの代わりに">forkの代わりに</h3>
<p>Rubyの<code>Kernel.fork</code>をはじめとするfork機能（例えば、<code>IO.popen</code>で<code>-</code>を渡すことを含む）はWindowsでは動作しない。 Perlerだった私としてはこれはかなり不満な点だ。Perlはコミュニティの努力により、forkがWindows上で動作する。これは、Windows版Perlではforkをエミュレートするためだ。</p>
<p>今回は、設定やドキュメントオブジェクトなどをセットアップした状態で、forkによって環境を独立させたいと考えていた。 これはグローバルなオブジェクトに変更を加えるためであり、また出力先の制御を<code>STDOUT.reopen</code>によって行うことができるかということについて考えていたためだ。</p>
<p>RubyのforkとWindowsについて検索すると、「forkは邪悪だ、threadを使え」という内容があふれる。 だが、今回は並列化のために使いたいわけではないため、Threadは用を成さない。</p>
<p>また、大量のドキュメントを変換する際のオーバーヘッド低減という目的もある。</p>
<p>Unicorn（Webアプリケーションサーバー）がこのforkによるCOWを活用した設計となっている。Unicornはどうしているのかと調べてみたら、UnicornもMongrelもWindowsでは動作しないらしい。</p>
<p>というわけで、forkの利用は諦めて、グローバルな名前に対する変更をいなす方向とした。</p>
<p>グローバルな名前のオブジェクトが変更されるのは、ほとんど</p>
<pre><code>DOC.is {
...
}</code></pre>
<p>という書式で記述するためだ。 これはPureDocドキュメントを分かりやすく記述するためであり、実際にテンプレートも<code>DOC</code>オブジェクトを利用したデザインとなっている。 つまり、<code>DOC</code>はthe PureDoc objectであることを期待している。</p>
<p>この設計を維持するため、Delegateライブラリを使用することとした。 実体は<code>DOC</code>ではなく、<code>DOC</code>はただのDelegatorというデザインだ。これはDOCに実体はなく、ただの代名詞となるわけだ。</p>
<pre><code>DOC = SimpleDelegator.new(nil)</code></pre>
<p>とすることにより、まず<code>DOC</code>という名前を用意しておく。 実際に新しいドキュメントを生成する場合は、</p>
<pre><code>::DOC.__setobj__ @@config[:puredoc_class].new</code></pre>
<p>のようにする。 これにより、<code>DOC</code>が意味するドキュメントを入れ替えることができ、<code>DOC</code>を変更しても、変更されるのは<code>DOC</code>ではなく、移譲されているドキュメントであり、<code>DOC</code>をまた新しいドキュメントにすることもできる。</p>

<!-- PBSEARCH_RESULT -->
        </article>
    </section>
    <footer id="InfoFooter">
      <ul>
        <li>© Masaki Haruka 2003.</li>
        <li>Generated by <a href="https://gitlab.com/reasonset/pbsimply-wpimporter">PureBuilder Simply WP Importer</a></li>
      </ul>
    </footer>
  </body>
</html>
