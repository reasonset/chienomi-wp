<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja" xml:lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="PureBuilder Simply WP Importer" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
    <meta name="author" content="Masaki Haruka" />
    <meta name="date" content="2018-04-26T00:00:00+09:00" />
    <meta name="dcterms.date" content="2018-04-26T00:00:00+09:00" />
    <title>【検索ワードに応えて】 ThinkPad X1 Carbon (2017, シルバー) のお話, Linux関連, その他 - Chienomi</title>
    <style type="text/css">article {
max-width: 1080px;
margin: auto;
}</style>
  </head>
  <body>

    <section id="ContentContainer">
      <header id="MainHeader"><a href="/"><h1>Chienomi</h1></a></header>
      <section id="ArticleBox">
        <header id="ArticleTitle"><h1>【検索ワードに応えて】 ThinkPad X1 Carbon (2017, シルバー) のお話, Linux関連, その他</h1></header>
        <article id="MainArticle">
<h2 id="序">序</h2>
<p>久しぶりの検索ワード反応企画。 ThinkPad X1 Carbon関連の検索が多かったので、併用されたワードに従ってコメントさせていただくことにする。</p>
<p>なお、ThinkPad X1 Carbonについては<a href="https://youtu.be/hnc8YxXYOCo">YouTube (はるかみ☆ チャンネル)</a>で開封動画を掲載させていただいているので、よかったらそちらもどうぞ。</p>
<p>また、そのほかLinux関連の検索にも回答させていただく。</p>
<h2 id="thinkpad-x1関連">ThinkPad X1関連</h2>
<h3 id="基本的なレビュー">基本的なレビュー</h3>
<p>ラップトップをガリガリ使うモバイラーなら持たない理由が見つからない。</p>
<p>XPS13のような13.3インチの中でも小型のものを除けばボディは13.3インチと変わりないサイズだ。 しかし14インチの画面は明らかに見やすく、作業もしやすいし、人に画面を見せるときにも良い。</p>
<p>そして非常に軽量でバッテリーマイレージも素晴らしい。 もちろん、キーボードはあらゆる現行ラップトップの中で最高だと思う。</p>
<p>唯一欠点としては天板の外板が弱い。 既に凹み、割れがある。それほど目立たないし、動作には問題ないのだが、ちょっとカナシイ。</p>
<h3 id="買い時について">買い時について</h3>
<p>「高性能」「最先端」などを意識したい場合はリリース間もない頃が良い。</p>
<p>リリース直後は割引はなく、およそ半年程度で30%程度の割引になる。モデル末期は40%を越える程度の割引だ。</p>
<p>基本的にはThinkPadの場合30%程度割り引いた状態で競争力のある通常価格で、割引のない最初期というのはフリーク向けと考えられる。 なので買い時を気にするような人なら直後はないだろう。</p>
<p>春頃には30%前後の割引になっていたりするから(現時点でサイト公式のクーポンが28%、恐らくメルマガや店頭クーポンならもう少し行くだろう)、それぐらいが買い時ではなかろうか。</p>
<p>少しでも安く買いたい人は、翌年モデルが発表されてから決めるといい。 その頃にはかなり安くなっているし、在庫が残っていれば翌年モデルが出てからでも安く買える。 翌年モデルを待つべきかどうかの判断も出来てお得だ。</p>
<p>2017と2018に関しては、X1 Carbonとしての進化は微々たるものだったけれど、第8世代プロセッサになったという点がとても大きい。 ただ、私はかなり安く買えたので、そのタイミングでよかったと思う。</p>
<h3 id="シルバーのthinkpadについて">シルバーのThinkPadについて</h3>
<p>良いと思う。</p>
<p>ThinkPadらしくないという批判はあるだろうけれども、マットだけれども黒のピーチスキンよりもサラッとした手触りで汚れもつきにくく目立たない。</p>
<p>シルバーのラップトップはそれなりに存在するので目立たないということは言えるけれども、「Hacker’s itemたるThinkPad」と「美しくおしゃれな高級ラップトップ」を両立させる意図は十分に達成できている。</p>
<p>控え目にいっても最高にかっこいい。</p>
<h3 id="国産と中国産について">国産と中国産について</h3>
<p>何も違わないから安心してほしい。 400万円するようなP920でも中国産だ。</p>
<p>なお、納期はかかる。X1は予定納期よりも遅かったという人が珍しくないようなので注意してほしい。</p>
<h3 id="その他の検索ワード回答">その他の検索ワード回答</h3>
<h2 id="シェルスクリプトの並列実行">シェルスクリプトの並列実行</h2>
<p>基本的な形式は次のとおり</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">(</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  <span class="bu">:</span> ...</a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">)</span> <span class="kw">&amp;</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="kw">(</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6">  <span class="bu">:</span> ...</a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="kw">)&amp;</span></a></code></pre></div>
<p>シェルスクリプトの並列実行は待ち合わせず投げっぱなしにするのが基本。</p>
<p>ただし、どうしても待ち合わたい場合は<code>wait</code>を使う方法もある。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">(</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  <span class="bu">:</span> ...</a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">)</span> <span class="kw">&amp;</span></a></code></pre></div>
<p>とした時、<code>$!</code>でサブシェルのPIDが取れるので、</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">(</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  <span class="bu">:</span> ...</a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="kw">)</span> <span class="kw">&amp;</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="va">proc1=$!</span></a></code></pre></div>
<p>としておけば待ち合わせる必要があるタイミングで</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="bu">wait</span> <span class="va">$proc1</span></a></code></pre></div>
<p>とすることができる。これはBashでもZshでも共通。</p>
<p>入出力をやりとりするのであれば、下流のパイプに流すべきで、親プロセスが出力を披露ようなことは考えないほうがよい。</p>
<p>どうしてもであればファイルに書いてwaitするか、もしくはZshならProccess Substitutionを使用する。</p>
<p>あるいは大量の処理があり、複数のワーカーを走らせたい場合は<code>flock</code>を使うのが無難だろう。 例えば以下のようにする。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode zsh"><code class="sourceCode zsh"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="co">#!/usr/bin/zsh</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="fu">worker()</span> <span class="kw">{</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">  <span class="kw">typeset</span> <span class="ot">qitem</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">  <span class="ot">worker_num=$1</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6">  <span class="kw">while</span> <span class="kw">true</span></a>
<a class="sourceLine" id="cb5-7" data-line-number="7">  <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">    <span class="kw">exec</span> <span class="kw">9&gt;|</span> .lock</a>
<a class="sourceLine" id="cb5-9" data-line-number="9">    flock -x 9</a>
<a class="sourceLine" id="cb5-10" data-line-number="10">    <span class="kw">read</span> <span class="ot">qitem</span></a>
<a class="sourceLine" id="cb5-11" data-line-number="11">    <span class="kw">exec</span> <span class="kw">9&gt;&amp;-</span></a>
<a class="sourceLine" id="cb5-12" data-line-number="12"></a>
<a class="sourceLine" id="cb5-13" data-line-number="13">    <span class="kw">if [[</span> <span class="ot">-n</span> <span class="ot">$qitem</span><span class="kw"> ]]</span></a>
<a class="sourceLine" id="cb5-14" data-line-number="14">    <span class="kw">then</span></a>
<a class="sourceLine" id="cb5-15" data-line-number="15">      <span class="kw">echo</span> -e <span class="st">&quot;\033[47m\033[1;30m   ***** Worker </span><span class="ot">$worker_num</span><span class="st"> : </span><span class="ot">$qiem</span><span class="st"> *****    \033[0m&quot;</span></a>
<a class="sourceLine" id="cb5-16" data-line-number="16">      <span class="co"># Some process</span></a>
<a class="sourceLine" id="cb5-17" data-line-number="17">    <span class="kw">else</span></a>
<a class="sourceLine" id="cb5-18" data-line-number="18">      <span class="kw">echo</span> -e <span class="st">&quot;\033[45m\033[1;37m   ***** Worker </span><span class="ot">$worker_num</span><span class="st"> ended. *****   \033[0m&quot;</span></a>
<a class="sourceLine" id="cb5-19" data-line-number="19">      <span class="kw">break</span></a>
<a class="sourceLine" id="cb5-20" data-line-number="20">    <span class="kw">fi</span></a>
<a class="sourceLine" id="cb5-21" data-line-number="21">  <span class="kw">done</span></a>
<a class="sourceLine" id="cb5-22" data-line-number="22"><span class="kw">}</span></a>
<a class="sourceLine" id="cb5-23" data-line-number="23"></a>
<a class="sourceLine" id="cb5-24" data-line-number="24"></a>
<a class="sourceLine" id="cb5-25" data-line-number="25"><span class="kw">cat</span> queue <span class="kw">|</span> <span class="kw">(</span></a>
<a class="sourceLine" id="cb5-26" data-line-number="26">  <span class="kw">for</span> i <span class="kw">in</span> <span class="dt">{1..3}</span></a>
<a class="sourceLine" id="cb5-27" data-line-number="27">  <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-28" data-line-number="28">    <span class="kw">(</span> worker <span class="ot">$i</span> <span class="kw">)</span> <span class="kw">&amp;</span></a>
<a class="sourceLine" id="cb5-29" data-line-number="29">  <span class="kw">done</span></a>
<a class="sourceLine" id="cb5-30" data-line-number="30"></a>
<a class="sourceLine" id="cb5-31" data-line-number="31">  <span class="kw">wait</span></a>
<a class="sourceLine" id="cb5-32" data-line-number="32">  <span class="kw">rm</span> .lock</a>
<a class="sourceLine" id="cb5-33" data-line-number="33"><span class="kw">)</span></a></code></pre></div>
<p>要点は以下の通りだ。</p>
<ul>
<li>関数<code>worker</code>が各ワーカーが実行する内容</li>
<li>これをサブシェル内で<code>worker n</code>の形で実行する</li>
<li>ファイルデスクリプタはクローンされるので、標準入力から読んだ場合、親シェルもサブシェルも同じものを読み進めるし、位置も同時に変化する</li>
<li>しかし、もし同時に読んでしまうとおかしなことになるので、読んでいる間は他のシェルに読んでもらっては困る</li>
<li>そこでロックファイルを作り、これをロックすることで排他制御する。いわゆるドットロック。</li>
<li><code>exec 9&gt;| .lock</code>でファイルデスクリプタ9番をロック用に確保</li>
<li>開きっぱなしになるので、<code>flock</code>でこのファイルをロック</li>
<li>ロックを獲得できたら標準入力から読む</li>
<li>読み終わったらファイルデスクリプタを閉じてロックも解放</li>
<li>これでキューから1行読めたので、処理を進める</li>
<li>「1行では足りないよ!」という場合、エントリをファイルに書いておいてディレクトリにまとめ、キューはファイル名にするとかすれば良い</li>
</ul>
<h2 id="amd-apu-godavarikaveri-と-linux">AMD APU (Godavari/Kaveri) と Linux</h2>
<p>特に問題はない。</p>
<p>以前はCatalystドライバのおかげでずいぶん苦労させられたけれども、 AMDGPUになって以来目立った問題は発生していない。</p>
<p>割と電気を食うけれど性能は微妙なので嬉しくはないと思う。 コストパフォーマンス的にみれば、これくらいの性能がおいしいという人は多いと思う。 ビデオ関連も充実しているし、Killerシリーズなんかは機能も充実しているしね。</p>
<h2 id="xmpp">XMPP</h2>
<p>ちょっと話題が広すぎて何を求めているのかがわからない。ごめんよ。</p>
<h2 id="dpi">DPI</h2>
<p>これかなり広い。</p>
<p>LinuxでのHi-DPIの話なら<code>/etc/X11/xorg.conf.d/</code>以下にモニターの設定ファイルを書く。 <code>40-monitor.conf</code>とかで。</p>
<pre class="x.org"><code>Section &quot;Monitor&quot;
    Identifier             &quot;&lt;default monitor&gt;&quot;
    DisplaySize            286 179    # In millimeters
EndSection</code></pre>
<p>で、KDE Plasmaを使うといい感じになる。 Plasmaを使わない場合については、Qtアプリケーションについてはなんとかなるけれど、GTKに関してはうまいことスケールしない。</p>
<p>LightDMに関してはGreeterの設定ファイルに<code>xft-dpi=</code>と書きましょう。</p>
<p>Hi-DPIはLinuxでは結構苦手にしている感じ。</p>
<p>フォントの設定はまた別。</p>
<h2 id="某人物について">某人物について</h2>
<p>コメントする気はありません。</p>
<h2 id="vp9のハードウェアエンコード">VP9のハードウェアエンコード</h2>
<ul>
<li>Intel QSVを使ってください</li>
<li>LinuxならVA-API経由ffmpegが良いよ</li>
<li>ただし<a href="http://chienomi.reasonset.net/archives/livewithlinux/1201">画質は絶望的だった</a>とは言っておく</li>
</ul>
<div class="sourceCode" id="cb7"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ex">ffmpeg</span> -vaapi_device /dev/dri/renderD128 -hwaccel vaapi -hwaccel_output_format vaapi -i source.mp4 -vf <span class="st">&#39;format=nv12|vaapi,hwupload,scale_vaapi=w=1280:h=720&#39;</span> -c:v vp9_vaapi -b:v 2.5M -strict -2 -c:a libopus -b:a 128k outfile.webm</a></code></pre></div>
<h2 id="intel-qsv-h.265">Intel QSV * H.265</h2>
<ul>
<li>LinuxならVA-API経由ffmpeg</li>
<li>速度はそこそこ。X.265とは雲泥の差。CPU負荷は0ではないというか、普通に40%くらいはいく</li>
<li>ちゃんとVA-APIドライバ入れようね</li>
</ul>
<div class="sourceCode" id="cb8"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ex">ffmpeg</span> -vaapi_device /dev/dri/renderD128 -hwaccel vaapi -hwaccel_output_format vaapi -i source.mp4 -vf <span class="st">&#39;format=nv12|vaapi,hwupload,scale_vaapi=w=1280:h=720&#39;</span> -c:v hevc_vaapi -c:a copy outfile.mp4</a></code></pre></div>
<h2 id="scale_vaapi">scale_vaapi</h2>
<p>VA-APIを使用する場合の出力画面サイズ指定。 変更しない場合は省略して大丈夫。</p>
<h2 id="amd-vce-nvidia-nvenc">AMD VCE / NVIDIA NVENC</h2>
<p>VCEはLinux的にはVA-API経由。なのでQSVと一緒。</p>
<p>ただし、AMDのビデオドライバはVA-APIだけじゃなくVDPAUも使える。 ところがVA-APIがエンコード/デコードなのに対してVDPAUはデコードのみ。</p>
<p>VA-APIをVDPAUに転送するドライバ(<code>libva-vdpau-driver</code>)と、VDPAUをVA-APIに転送するドライバ(<code>libvdpau-va-gl</code>)があり、 VDPAUを有効にして、VA-APIに転送するドライバを使ってしまうと(Nvidiaの場合はVA-APIが使えないのでこうする)デコードのみになってしまって使えない。</p>
<p>ちゃんと<code>libva-mesa-driver</code>を使いましょう。</p>
<p>Nvidiaの場合はVA-APIをサポートしておらず、VDPAUはエンコードができないので、 NVENCは専用のインターフェイスになっている。</p>
<p>どっちが優れているというのは難しいけれど、Nvidiaのほうが対応フォーマットは多い。</p>
<h2 id="discordとslack">DiscordとSlack</h2>
<p>基本的にはDiscordがいいと思うし、最近はSlackも微妙だと思うのだけれども、「両方あると嬉しい」という面もある。</p>
<p>Discordの場合「ユーザーという概念がある」ということが大きい。</p>
<p>Discrodでつながると、どのようなつながりであれ、「その人」というのが見えてしまう。 Discordは通知をカスタマイズできないため、「通知をオンにしている全ての人からの通知が一律に行われる」ということになる。 棲み分けをする方法がない。</p>
<p>これはLINEと同様の問題である。 恋人だろうが、ゲーム仲間だろうが、仕事の人間だろうが、区別する方法がないのだ。 アカウントの切り替えは難しいためアカウントで分けるのも現実的ではないし、アカウントで認識されているから一時的な連絡先にもしにくい。</p>
<p>Slackの場合はやりとりもつながりもあくまでそのチーム内でのことなので、仕事の関係などであればSlackのほうが便利だ。</p>
<h2 id="自前メールサーバーからのメールをgmailが受け取らない">自前メールサーバーからのメールをGMailが受け取らない</h2>
<p>主にはホスト認証の関係。</p>
<p>GMailは送られてきたメールサーバーが、本当にそのメールを送る資格があるかをチェックする。</p>
<p>設定方法はいくつかあるけれど、SPFレコードを書くのが楽。 「メール SPF」で検索すると色々出てくる。</p>
<h2 id="linuxとrealtek-ネットワークカード-rtl8152ほか">LinuxとRealTek ネットワークカード (RTL8152ほか)</h2>
<p>ASIXよりはマシだけれど安定して苦しめてくれるRealTekのネットワークカード。</p>
<p>Linuxではネットワークアダプタは</p>
<p>Intel &gt; Atheros (Killer) &gt; Broadcom &gt; RealTek &gt; Asix</p>
<p>だからね。</p>
<p>RealTekのWiFiモジュールであるRTL8152のドライバはカーネルモジュールとしてある。 Arch Linuxの場合はDKMSになっていて、AURからインストール可能。 場合によってはRTL8153をブラックリストに入れる必要がある。</p>
<p>インストールしなくても動作はするけれど、うまく交信できなくなったりする。 安定性の面から言えば入れるべきだけれど、入れたところでうまくいかない場合もある。</p>
<p>「うちのディストリビューションにはないよ!!」という方。 Archにおいで。むしろManjaroにおいで。</p>

<!-- PBSEARCH_RESULT -->
        </article>
    </section>
    <footer id="InfoFooter">
      <ul>
        <li>© Masaki Haruka 2003.</li>
        <li>Generated by <a href="https://gitlab.com/reasonset/pbsimply-wpimporter">PureBuilder Simply WP Importer</a></li>
      </ul>
    </footer>
  </body>
</html>
