<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja" xml:lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="PureBuilder Simply WP Importer" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
    <meta name="author" content="Masaki Haruka" />
    <meta name="date" content="2016-06-07T00:00:00+09:00" />
    <meta name="dcterms.date" content="2016-06-07T00:00:00+09:00" />
    <title>シェルスクリプトで並列実行制御を行う - Chienomi</title>
    <style type="text/css">article {
max-width: 1080px;
margin: auto;
}</style>
  </head>
  <body>

    <section id="ContentContainer">
      <header id="MainHeader"><a href="/"><h1>Chienomi</h1></a></header>
      <section id="ArticleBox">
        <header id="ArticleTitle"><h1>シェルスクリプトで並列実行制御を行う</h1></header>
        <article id="MainArticle">

<p>シェルスクリプトを書く場合において、処理を順次おこないたいことは多いはずだ。
多くのディレクトリや処理のリストなど、順に処理を適用していくケース。</p>

<p>まず、この設計だが、「ある特定の場所でしか実行されないスクリプト」は<code>noexec</code>が指定されていない限りはそのルートに設置すべきだと思う。
対象ディレクトリごとにスクリプトが異なってくる場合はその対象ディレクトリごとにスクリプトを設置する。
もしそうでなく、その違いがディレクトリのパス自体に含まれるのであれば、単純に対象ディレクトリに空のドットファイルを置けばよいと思う。</p>

<p>例えば、…/.somescriptを実行するのであれば、トップに</p>

<pre><code>for i in **/.somescript
do
  ( cd ${i:h}; zsh .somescript )
done
</code></pre>

<p>のようなスクリプトを書けば良い。Gitが「Gitを実行するディレクトリがリポジトリになる」という仕様なので、このように方法にらも随分なれてしまった。
もし、パス要素自体が重要になるのであれば、</p>

<pre><code>for i in **/.target
do
  fooscript ${${i:h}:t}
done
</code></pre>

<p>という方法も考えられる。</p>

<p>それは良いとして、その各処理が時間がかかるとしたらどうだろう？
これは別にディレクトリ単位であった場合に限らない。テキストファイルに1行1エントリ形式で書いて読みながら処理する場合も同様だ。</p>

<p>別に最初からターゲットをグループ分けしてもいいし、xargsを使って3つずつ実行する、といったことで並列化することもできる。
だが、できれば常に3スレッドで実行する、といったモデルのほうが好ましいのではなかろうか。</p>

<p>これを実現するためにシェルスクリプトで並列実行制御したいのだが、残念ながらこれはかなり難しい。
Zshでもzthreadがあるような話も目にするのだが、まぁ実際はそうもいかなそうだ。</p>

<p>並列実行の難しさは、「同時アクセス」にある。あるリソースに同時にアクセスした場合、いろいろな形でおかしなことになる。
ファイルデスクリプタを共有すれば良いのではないかと考えたのだが、</p>

<pre><code>worker() {
  workern=$1
  typeset val
  while read val
  do
    print "Worker $workern: $val"
  done
}

print -l {1..100} | (
  for n in {1..3}
  do
    worker $n &amp;
  done
)

wait
</code></pre>

<p>結局<code>read</code>時に同時アクセスするとおかしな値を取ることになり(空文字列だったり、複数行がぐちゃぐちゃに混ざったものだったりする)、ちゃんと動作しない。</p>

<p>なお、ここでのポイントをまとめておこう。</p>

<ul>
  <li><code>()</code>はfork子プロセスを生成し、子プロセスで実行する。</li>
  <li>この子プロセスに渡されたパイプは、子プロセス自体の標準入力として受け取ることになる。リダイレクトしないプロセスはこのファイルデスクリプタを共有する</li>
  <li>&amp;でバックグラウンドで実行する。子プロセスを生成したかどうかは関係がない</li>
  <li>外部コマンドは<code>fork</code>+<code>exec</code>で子プロセスを生成するが、関数は生成しない</li>
  <li>waitはジョブを共有待ち合わせる。引数なしですべてのジョブを待つ</li>
  <li>同じファイルデスクリプタを共有している場合、IOの位置もいずれかのプロセスが動かせばすべてのプロセスで動く</li>
</ul>

<p>結局、アクセスしたら要素をひとつ返してくれるQueueがほしいのだ。</p>

<p>そこでまじめに考えてみた。一番単純なのは<code>flock</code>を使う方法なのだが単純にはいかない。プロセスの中で処理したければ、ファイルデスクリプタを使った、複雑な方法が必要になる。
その中で比較的スマートに処理できると考えたのが<a href="https://gist.github.com/reasonset/782725e1648aca2d60fa96590433f2f4">Gist</a>のスクリプトだ。</p>

<script src="https://gist.github.com/reasonset/782725e1648aca2d60fa96590433f2f4.js"></script>

<p>この場合、.lockは空ファイルであり、単なるロックでしかない。無駄なファイルを作るのにはちょっと抵抗があるが、方法としては比較的簡単だ。
この方法はbashでもほぼ同様に書くことができる。あまりzshらしい方法とは言えない。</p>

<p>なんか悔しいので、Zshらしい方法として、Socketを使うという方法を提案してみる。
UNIXドメインソケットはファイルパスを用いてプロセス間通信を行う。TCP同様、サーバーが接続を受け付け、IOを確立するものだ。</p>

<p>一般的にはサーバーは並列処理できるように接続の受け付けはマルチスレッドで行う。</p>

<pre><code>zsocket -l foo
integer server=$REPLY
	
while zsocket -a $server
do
(
  integer io=$REPLY
  ...
) &amp;
done
</code></pre>

<p>だが、シングルスレッドで行った場合はどうなるか。listenはしているがacceptはしていない状態だと接続しようとするclientはブロックされ、acceptされるまで待たされることになる。
結果的に、あるリソースにアクセスし、供給する部分がシングルスレッドになる。同時にアクセスしてもproducerはそれをブロックして順番に渡していくことになる。</p>

<p>これはごく普通のマルチプロセスモデルであり、Perlはthreadが非推奨で、UNIXドメインソケットの利用を推奨している。
そのため特に目新しいものではないのだが、Zshでおこなう(シェルスクリプトで行う)というとまたちょっと味があるのではないか。</p>

<p><a href="https://gist.github.com/reasonset/52ec7e199d24a2f7c6c53446dbc8ad2b">Gist</a></p>

<script src="https://gist.github.com/reasonset/52ec7e199d24a2f7c6c53446dbc8ad2b.js"></script>


<!-- PBSEARCH_RESULT -->
        </article>
    </section>
    <footer id="InfoFooter">
      <ul>
        <li>© Masaki Haruka 2003.</li>
        <li>Generated by <a href="https://gitlab.com/reasonset/pbsimply-wpimporter">PureBuilder Simply WP Importer</a></li>
      </ul>
    </footer>
  </body>
</html>
