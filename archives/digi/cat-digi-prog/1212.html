<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja" xml:lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="PureBuilder Simply WP Importer" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
    <meta name="author" content="Masaki Haruka" />
    <meta name="date" content="2018-02-19T00:00:00+09:00" />
    <meta name="dcterms.date" content="2018-02-19T00:00:00+09:00" />
    <title>継承の使いどころ - Chienomi</title>
    <style type="text/css">article {
max-width: 1080px;
margin: auto;
}</style>
  </head>
  <body>

    <section id="ContentContainer">
      <header id="MainHeader"><a href="/"><h1>Chienomi</h1></a></header>
      <section id="ArticleBox">
        <header id="ArticleTitle"><h1>継承の使いどころ</h1></header>
        <article id="MainArticle">
<h2 id="序">序</h2>
<p><a href="https://www.mimir.yokohama/devel-detail.html">業務のほう</a>でやっていたプログラミングが久しぶりに設計を4回もやる苦戦となった。</p>
<p>苦戦というよりは模索したというほうが近いが、「作るより変更するほうが難しい」の一例となった。</p>
<p>作業としては、出力機能にバリエーションが増えることだった。</p>
<p>入力データは変わらないのだが、出力データに関してはその違いが様々な面で出てくる(文字エンコーディングの違いなのだが、JIS XかUnicodeかという違いでもある)。 そのため入力処理あるいはデータアッセンブルの段階で処理してもいいし、出力時に処理してもいいし…という状態だった。</p>
<p>既に600行を越えているプログラムであるため、あまり変更すると変更量が増えてしんどいしバグにもなりかねない。 かといって単純に分岐してしまうとメンテナンスが困難になり、リファクタリングしておくほうがいい。</p>
<p>大部分は同じだが、変数で済むほどには同じじゃない、という加減が問題だった。</p>
<h2 id="データ用クラスを作る">データ用クラスを作る</h2>
<p>最初に考えたのがこれだった。</p>
<p>現状、データ自体は複数のインスタンス変数に分かれたHashで保持している。</p>
<p>これをクラスとして独立させ、これに出力機能を与える、というものだった。</p>
<p>この際、データをストアするメソッド(現状では<code>Hash#[]</code>-&gt;<code>Array#push</code>)にデータの加工を含めるという方法を考えた。</p>
<p>だが、これは現在とは異なるフローである。現状では入力処理はデータのアッセンブルと出力データのための加工を並行して行っている。 これを実現するためにはこの点も変更しなければならず、一見スマートに見える方法だったが、これは呼び出し側から見ればカプセル化によってスマートに見えるだけで、実際はあまりキレイな実装にはならなそうであった。</p>
<p>一見ゴリ押しに見える現在の設計だが、再考してみると案外合理的なのである。 大幅な変更がリファクタリングとして有効に働くかは結構疑問であった。</p>
<p>また、データオブジェクトだけではなくフロー制御で使われるデータもあり、 データオブジェクトとフロークラスでいくつものインスタンス変数を共有する必要があった。 これはあまり美しくない。</p>
<p>変更点が大きくバグを生じる可能性が高かったため、この方法は断念した。</p>
<h2 id="異なる部分をメソッド分けする">異なる部分をメソッド分けする</h2>
<p>「避けたい」と思いつつもどれくらい複雑になるか考えてみた。</p>
<p>これまでひとつのメソッドに組み込まれていた一部をパーツとして分離し、メソッドとして切り出す。 もちろん、これは悪いことではない。</p>
<p>そして、異なる処理を行うメソッドを追加する。 ここまではまだいい。</p>
<p>だが、そのどちらのメソッドを起動するかということについては従来のメソッド上で条件分岐しなくてはいけない。</p>
<p>別に今後増えることも減ることもないのならばそれでもいい。 だが、今回追加されたJIS機能は「将来的に削除する予定の」機能である。 実際仕様書にも「容易にバイパスできるように」と書いてある。</p>
<p>フラグだけで条件分岐を回避するというだけのコードは明らかに汚くなってしまう。</p>
<h2 id="違いをモジュールで吸収する">違いをモジュールで吸収する</h2>
<p>「違いが生じる部分をMix-inすることにして、Mix-inするモジュールの選択によって挙動を変えよう」というアイディアが生じた。</p>
<p>これは、出力するたびに入力をやり直すことになるが、フィルタとして機能するようなプログラムではないのであまり問題はない。 入力処理もそこまで極端に重いわけでもない。 入力データのSanity checkや分類にも両者に違いがあるため、実行時は分離したほうが良い考えに思えたのだ。</p>
<p>もちろん、両方生成する場合は非効率的だが、その程度は受容できるだろう。</p>
<p>だが、このアイディアはすぐ適切でないと分かった。 出力系統によって一部だけ変更/追加したい、ということがあるのだが、共通処理から分岐するたびにメソッドの有無をチェックしてあるなら呼び出す…ということになってしまう。 これは明らかに<code>super</code>したい状況であるにも関わらず、だ。</p>
<p>だが、Mix-inされたモジュールのインスタンスメソッドよりクラスのインスタンスメソッドのほうが優先度が高いため、これはうまくいかない。 比較的新しい機能である(といってもRuby 2.0だけれど)<code>Module#prepend</code>しても良いのだけれど、これはちょっと違うように思われる。 そもそも正しい継承関係と逆で、設計が歪なのだ。</p>
<h2 id="継承する">継承する</h2>
<p>「出力の固有特性を持っているほうがサブクラス」であることが自然だと思うなら、サブクラスにすれば良いじゃない！というわけで継承することにした。</p>
<p>従来のクラス名を維持すれば互換性を保つこともできるが、従来型(Unicode)と新機能(JIS)は並列の存在であるため、名称を<code>ABC</code>と<code>ABC::DEF</code>のような関係にはし難い。 そこで、ベースクラスはベースクラスで名称をつけ、UnicodeクラスとJISクラスを用意することにした。</p>
<p>この構造は、共通部分も多いがそれぞれ部分的に違い、また全面的にオーバーライドできるものではないため、 共通処理をベースクラスに記述し、サブクラスから<code>super</code>を呼んだり、メソッド中で部分的に異なる点はサブクラスで実装されているメソッドで異なる処理をする。</p>
<p>リファクタリングするならば差異のある部分のメソッド構造を変更し、容易にオーバーライドできるようにする、また処理の一部はコール時のブロックにする、といったことが考えられる。</p>
<p>共通部分があって一部違う挙動を示すものがあるとき、継承を使う、ということ自体はごく当たり前のことだ。</p>
<p>しかし、「従来一本道だった処理で複数の異なる挙動を持つプログラムにする」というときに新たに「共通のスーパークラスを作って」継承を利用する、という発想はなかなか出てこなかった。</p>
<p>しかし結果的には、これぞ継承の使い方という見本のようなものになったな、と思う。</p>

<!-- PBSEARCH_RESULT -->
        </article>
    </section>
    <footer id="InfoFooter">
      <ul>
        <li>© Masaki Haruka 2003.</li>
        <li>Generated by <a href="https://gitlab.com/reasonset/pbsimply-wpimporter">PureBuilder Simply WP Importer</a></li>
      </ul>
    </footer>
  </body>
</html>
