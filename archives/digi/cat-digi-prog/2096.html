<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja" xml:lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="PureBuilder Simply WP Importer" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
    <meta name="author" content="Masaki Haruka" />
    <meta name="date" content="2019-09-02T00:00:00+09:00" />
    <meta name="dcterms.date" content="2019-09-02T00:00:00+09:00" />
    <title>「事前生成戦略」の原点、チャットスクリプト (コードつき) - Chienomi</title>
    <style type="text/css">article {
max-width: 1080px;
margin: auto;
}</style>
  </head>
  <body>

    <section id="ContentContainer">
      <header id="MainHeader"><a href="/"><h1>Chienomi</h1></a></header>
      <section id="ArticleBox">
        <header id="ArticleTitle"><h1>「事前生成戦略」の原点、チャットスクリプト (コードつき)</h1></header>
        <article id="MainArticle">
<h2 id="序">序</h2>
<p>チャットの開発、そして事前生成戦略に到達する下りはなんども書いているが、それが非常に革命的で、「極めてシンプルにすることができた」という話はそれだけではピンとこないのが普通だろうから、コードを添えて解決することにする。</p>
<h2 id="事前生成戦略">事前生成戦略</h2>
<p>PureBuilder Simplyで採用されている「事前生成戦略」は、私にとってはウェブアプリケーション開発におけるウリのひとつになっている。</p>
<p>その内容は、基本的に「ユーザーが要求するものは静的HTMLであるようにする」ということである。</p>
<p>キッカケはNginxだった。 2005年にはもう取り組み始めていたのだから、かなり感度は高かったといえるだろう。</p>
<p>当時、私のwebサーバーはApache 1.3だったが、結局はこのあとLighttpdへの移行することになる。 そしてその後はまさかのDeleGateへと先祖返りする。</p>
<p>だが、Nginxを検討したのは「静的ファイルの応答速度を重視している」という設計のためだ。</p>
<p>2005年には、ADSLの普及により回線速度がだいぶ向上していた。結果的に、従来では考えられないくらいチャットに対するリクエストが増大するという問題が発生していた。 ちなみに、当時のHTMLチャットといえば、「みんなでアクセスするとエラーになるもの」であり、ログ表示がおかしかったり、発言が消えたり、ページが取得できなかったりということは日常的にあった。</p>
<p>だが、そもそもwebサーバーは静的なページを配信するのが最も基本であり、静的なページにすることで多くの問題が解決するものと思われた。 そもそも、静的なページを取得するのであれば、CGIスクリプトは起動されず、負荷はとても少ない。 また、セキュリティ上のリスクなども(webサーバーが自分の責任で保守しているのではないなら)考えなくて良い。</p>
<p>少なくとも、静的ページを配信することはセキュリティ上もパフォーマンス上も良いことであるのは確かだ。</p>
<h2 id="チャットで事前生成戦略">チャットで事前生成戦略</h2>
<p>そもそも、チャットで問題が起きる理由は、「新しい発言を取得しようとしてリロードボタンを連打するから」であり、一種のF5アタックを仕掛けることになるからだ。</p>
<p>仮にF5アタックがさけられないとするならば、更新されるものが静的HTMLであればスクリプトが呼ばれることはなく、随分軽くなる。</p>
<p>私はそもそも、チャットスクリプトは随分長く開発に取り組んでいた。 その目的は既存のフリースクリプトを利用していた状況からの脱却であり、私がプログラミングを再開したときにまず行ったのは、チャットスクリプトを改造すること、そして学習の一環としてそれら(特にPerl4で書かれているもの)をモダンに書き換えることだった。</p>
<p>私のサイトでメインで使われてきたチャットスクリプトは「ゆいちゃっと2000」のち「TeaChat」であるが、サイト全体では非常に多くのチャットスクリプトを動作させていた。 フリースクリプトを比較すると同時に、私の開発テストでもあった。 舞台となったのはfreeweb、そしてロリポップ!である。</p>
<p>プログラミング言語を学習する過程でも、「その言語に適した形でチャットスクリプトを再実装する」という目標があり、 制作した「TeaChatのクローンスクリプト」は、Perl5(オブジェクト指向版), Ruby 1.8, PHP5, Python 2.4となかなか多い。</p>
<p>TeaChatのクローンスクリプトを書く中で感じたのは、 「チャットスクリプトは結局のところ、発言があったときはログを更新するという操作があるが、そうでないときはログを読んでHTMLをビルドしているだけである」ということだ。</p>
<p>この気持ちがより強くなったのは、eRubyを学んだときだった。 チャットのページは、eRubyエンジン、eRubyテンプレート、ログファイルがあれば生成可能であり、Rubyスクリプトは必要としない。 だが、TeaChatに準じると、わざわざRubyスクリプトであれやこれやしてからeRubyエンジンを呼び出すことになる。</p>
<p>そして、何度も何度もリロードによってHTMLをビルドすることになるのだが、更新するのは発言するときだけであり、ビルドする頻度に対して更新する頻度は極めて低い。 更新されていなければ、全く同じ内容のページをビルドしているわけである。これは、この上ないほど無駄だ。</p>
<p>だったら、更新があったときだけHTMLを更新して、ユーザーはHTMLを読めばよいではないか。</p>
<p>結果的には、フレームだけでなく、発言用ページも、チャットページも全て静的HTMLという設計ができあがった。 唯一、発言フォームのsubmit先がCGIであり、これは当初は静的HTMLそのものを編集する、というものだった。 のちに、eRubyを使ってログから生成する設計に変更される。</p>
<h2 id="具体なコード">具体なコード</h2>
<p>当時のコードは残っていないが、<a href="https://github.com/reasonset/demo-simplest-htmlchat">GitHubにその概要を実装したものを上げた</a>。</p>
<p>TeaChatほど高機能なわけではないが、当時のHTMLチャットとして基本的な機能は備えている。 PerlのチャットCGIは小さなものでも300行程度はあったことを考えると、39行というのは驚異的な小ささである。 しかも、このスクリプトはWebrickサーブレットになっており、サーバー機能すら自分で賄う。</p>
<p>本質部分はわずか8行で、</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb1-1"><a href="#cb1-1"></a>cgi = req.query</span>
<span id="cb1-2"><a href="#cb1-2"></a>chat.unshift({<span class="st">name: </span>esc(cgi[<span class="st">&quot;name&quot;</span>]), <span class="st">timestamp: </span><span class="dt">Time</span>.now.strftime(<span class="st">&quot;%y-%m-%d %T&quot;</span>), <span class="st">chat: </span>esc(cgi[<span class="st">&quot;chat&quot;</span>])&amp;.[](<span class="dv">0</span>, <span class="dv">1024</span>)})</span>
<span id="cb1-3"><a href="#cb1-3"></a>chat = chat[<span class="dv">0</span>,<span class="dv">30</span>]</span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="dt">File</span>.open(<span class="st">&quot;chat.log&quot;</span>, <span class="st">&quot;w&quot;</span>) <span class="kw">do</span> |f|</span>
<span id="cb1-5"><a href="#cb1-5"></a>  <span class="dt">Marshal</span>.dump chat, f</span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="kw">end</span></span>
<span id="cb1-7"><a href="#cb1-7"></a>chat_content = <span class="dt">ERB</span>.new(<span class="dt">CHAT_HTML</span>).result(binding)</span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="dt">File</span>.open(<span class="st">&quot;chat.html&quot;</span>, <span class="st">&quot;w&quot;</span>) {|f| f.puts chat_content}</span></code></pre></div>
<p>となっている。ここでは</p>
<ul>
<li>パラメータを読み込み</li>
<li>パラメータをオブジェクト化してチャットログに追加し</li>
<li>ログを保存して</li>
<li>HTMLにビルドして</li>
<li>HTMLファイルとして保存する</li>
</ul>
<p>という手順である。</p>
<p>リロード間隔は5秒と短いが、手動で連打されるよりははるかにマシなので、手動ではやりにくい仕様になっている。</p>
<p>事前生成戦略をとることでコードが短くなり、バグの余地も減った。 そして、設計自体が単純になり見通しもよくなった。基本的に、良いことづくめである。</p>
<h2 id="事前生成戦略の応用">事前生成戦略の応用</h2>
<p>では、このような事前生成戦略が有効なケースを考えてみる。</p>
<p>掲示板システムなどは、より読むことが多く、より適している。 そのように考えていくと非常に多くのケースに使えるということがわかる。</p>
<p>なによりもすごいのが、ブログのような発信型のコンテンツだ。</p>
<p>このようなものは当時、ページマスタリングシステムと呼ばれていた。 その要点としては、テンプレートがあることでページヘッダなど共通の部分を一箇所にまとめ、コンテンツ部分だけが異なるものを書こう、というようなことだ。</p>
<p>しかし、ブログシステムでこれを使うのは明らかに過剰である。 現在でいえば、Pandocですらそれは叶えられるのだ。</p>
<p>このことから、「テンプレート機能のサポート」「PODのようなより簡単にコンテンツを記述できる言語のサポート」の2点がテーマになった。 前者はPureBuilderとして、後者はPureDocとして実装されることになる。これに「記事の前後関係をもたせる」ことを目標としたのがACCSだ。</p>
<p>これらの大きなメリットとして、事前生成戦略ならではの「軽さ」だけでなく、実装が容易であり、なおかつ安全であるということがいえる。</p>
<p>まず、ログイン機能、管理機能などを実装する必要がない。 単純にファイルとして生成するものなので、「ファイルの編集」という概念に吸収される。 これで実装がとても楽になる。</p>
<p>さらに、webに対する攻撃というのはほとんどが定番webアプリケーションの機能を起動しようとしたり、ログインを試みるものであるから、単なる静的HTMLファイルでは攻撃の起点がない。 非常にセキュアである。</p>
<p>「事前生成戦略」という考え方からすれば、そもそも手元で静的ファイルに変換してしまうPureDoc/PureBuilderはより発展的な考え方であった。 これとは別に、検索ページのようなオンデマンドで提供される必要があるものはこの考え方が通用しない。むしろ、負担になる場合すらある。 そのために、「遅延生成戦略」というものも編み出された。これは、「例えページが更新される状況が起きたとしても、最初にアクセスされるまではページを実際には更新しない」というものである。 ただ、これ自体はほとんど「コンテンツキャッシュ機能」と変わりがなく、それほど独特なものではない。生成するべきかどうかを判断するために、リクエストはスクリプトが受け付けなくてはならないからだ。 実際に遅延生成戦略を取ったアプリとしてはMongrelを用いたサーブレットとして実装されたものがいくつかあるが、キャッシュとして以上の効果は発揮できず、この話を大いにすることはなくなった。</p>
<h2 id="郷愁-探求-求道">郷愁, 探求, 求道</h2>
<p>今にしてみれば意外に思われるかもしれないけれど、私は当初から「変わったコード」「きわどいコード」を書いていたわけではない。 そもそも私は完璧主義者だったし、ものすごくきっちりしたコード、学習時に使用したものを正しく踏まえたコードを書いていた。</p>
<p>だが、当時から好奇心は強かったし、真理の探求という傾向も強かった。チャットスクリプトの再実装を繰り返す中で、「これは本当に必要か?」「こう書いたほうが本質的で端的なのでは」という疑問が次々湧き上がり、 1年くらいは耐えていたが、結局は徐々にアレンジを加えるようになっていった。</p>
<p>「別にアプリケーションで応答する必要はないじゃないか」というところに至るのがその流れだ。 サンプルでは本質部分だけを書くことをテーマにしているが、実際にはTeaChatに存在する機能は全て網羅するものを制作した。 TeaChatには電報機能があり、これはprivate messageである。つまり、「ユーザー固有のチャットを事前生成する」という戦略に成功していたことを意味する。</p>
<p>これは2バージョンあり、最初のバージョンではユーザーごとに固有のHTMLファイルを開くようになっていた。 こちらはやや複雑で、</p>
<ul>
<li>フレームページとしてディスパッチャが呼ばれる</li>
<li>ディスパッチャはUIDを生成し、UIDのディレクトリを作成してベースとなるHTMLファイルを出力する</li>
<li>フォームにはUID値を覚えておく</li>
<li>当該チャンネル上で一定時間内に発言のあったUIDを覚えておき、そのUIDを更新対象にする</li>
</ul>
<p>可能な限り漏れがない仕様ではあるのだが、見てわかるとおり完全ではない。 電報リストのためにF5しなければならないというのが最も大きい問題だろうか。</p>
<p>後発の仕様はAjax仕様であり、XMLHttpRequestを使う。 HTML内にメッセージIDが埋め込まれており、そのメッセージIDが未知のものであれば、XMLHttpRequestによって追加で取得する。取得したメッセージはJavaScriptによってタイムスタンプでソートし、チャットに混ぜ込まれる。 HeartComではこれを発展した形式になっており、PM用(というよりuser relem用)のアプリケーションが独立して存在する。そしてXMLHttpRequestによってポーリングを行い、メッセージが受信できるようになっている。</p>
<p>結局このチャットにおける事前生成戦略採用が転機になった。 このスクリプトは、常識や、正しいとされていることとは全く異なる。だが、完全に正しく動作し、意図を達成できる。</p>
<p>至って本質的だ。この事実は「本質は端的に表せる」ということを意味しており、その正誤自体は結果<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>によって証明できる。 また、正しく動作する限りいずれも正しいのであり、世の中で正しいとされている手法や常識はどちらかといえばそれに依存している。つまり、「正しいが、最適であるかどうかは別」である。</p>
<p>以降、私は端的なコードを目指すことになる。 本質がなにかを見極めることができればコードは劇的に短くなる。もちろん、場合によっては泥臭くても今思いつく方法で解決したほうが良い場合もある。 だが、それだけでは成長がない。とにかくタンテ的なコードを目指す。それも、できるだけ短時間で、だ。 私の向上が、求道が始まった。</p>
<p>この求道はなにも「事前生成戦略」というテクニックにとどまらず万事に及んだ。 途方もなく困難に思われたことも、今ならできる。</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>結果は現象であり、この「結果」を「売上」や「人気」で測ろうとすると真実にはたどり着けない。<a href="#fnref1" class="footnote-back" role="doc-backlink">&#x21a9;︎</a></p></li>
</ol>
</section>

<!-- PBSEARCH_RESULT -->
        </article>
    </section>
    <footer id="InfoFooter">
      <ul>
        <li>© Masaki Haruka 2003.</li>
        <li>Generated by <a href="https://gitlab.com/reasonset/pbsimply-wpimporter">PureBuilder Simply WP Importer</a></li>
      </ul>
    </footer>
  </body>
</html>
