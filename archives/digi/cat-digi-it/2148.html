<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja" xml:lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="PureBuilder Simply WP Importer" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
    <meta name="author" content="Masaki Haruka" />
    <meta name="date" content="2019-10-07T00:00:00+09:00" />
    <meta name="dcterms.date" content="2019-10-07T00:00:00+09:00" />
    <title>RAIDについて - Chienomi</title>
    <style type="text/css">article {
max-width: 1080px;
margin: auto;
}</style>
  </head>
  <body>

    <section id="ContentContainer">
      <header id="MainHeader"><a href="/"><h1>Chienomi</h1></a></header>
      <section id="ArticleBox">
        <header id="ArticleTitle"><h1>RAIDについて</h1></header>
        <article id="MainArticle">
<h2 id="序">序</h2>
<p>「RAIDがわからない」という話をちょいちょいいただくようになったので、RAIDについて簡単に解説しようと思う。</p>
<p>ここでは単純にRAIDのよくある説明をするだけでなく、RAIDの実装や、クラスタストレージなどにおける冗長/高可用実装などについても軽く触れていこうと思う。</p>
<p>なお、計算に関しては現実的な色々を抜きにしているので、ツッコミはなしにしてほしい。</p>
<h2 id="raidの概念">RAIDの概念</h2>
<p>RAIDは複数のディスクをまとめて1台のディスクとして取り扱うための技術。</p>
<p>ディスクの冗長性を確保する技術だが、RAIDは必ずしも冗長性を持つわけではない。</p>
<p>「複数のディスクをまとめる」技術の中のひとつがRAIDであり、同様の技術はRAID以外にも存在する。 こうしたディスクをまとめる技術を一般化してRAIDと呼ぶ場合もあるが、RAIDの中に種類があり、その種類を限定することが多いのであまり一般的な用法ではない。 せいぜいメニューがまとめられる程度である。</p>
<h2 id="ディスクアレイ">「ディスクアレイ」</h2>
<p>RAIDで組まれた一群のディスクを「ディスクアレイ」と表現する。</p>
<h2 id="raid">RAID</h2>
<h3 id="raid0-ストライピング">RAID0 (ストライピング)</h3>
<p>RAID0はデータを分割し、複数のディスクに渡って分散して記録する。</p>
<p>一般的にはブロックサイズで分割するものであり、512kBずつディスク1, ディスク2, ディスク3…と記録していく。 このストライプサイズは設定できる場合もある。</p>
<p>RAID0は同一データを分散して記録するため、大きなデータをシーケンシャルに読み出す場合にディスク台数にほぼ比例してディスク速度が向上する。</p>
<p>ランダムアクセスに対しては、基本的にある程度高速化できる場合が多いが、激しいランダムアクセスがある場合分散記録(ファイルディストリビュート)よりも速いとは言い切れない。</p>
<p>一方で、耐障害性は <em>低下し、</em> 冗長性は <em>全くない</em>。</p>
<p>故障確率は</p>
<pre><code>ディスク故障率 * ディスク数</code></pre>
<p>に上昇する。</p>
<h3 id="raid1-ミラーリング">RAID1 (ミラーリング)</h3>
<p>n台のミラーレッグに対して同一のデータを書き込む。</p>
<p>冗長性はレッグ数に比例し、障害確率は</p>
<pre><code>ディスク故障率 ** ディスク数</code></pre>
<p>に減少する (ディスク故障率なので、これは <code>≦1</code>である)。</p>
<p>簡単なものなので実装しやすく、備わっていることも多く、なおかつ確実に効果が出る。</p>
<p>一方、そもそも容量増加の効果がなく、レッグ数が増えても耐障害性は上がるが、容量は増えない。 ディスク台数が増えると容量効率はどんどん悪くなる。</p>
<p>モダンな実装だと、ミラーレッグ数のミラーを連結した形で扱うことができる(RAID10相当か、RAID1のJBOD)場合がある。</p>
<p>ミラーリングでストライピングのような読み出し方をすることも可能ではあるけれども、実際そうなっている実装は稀。</p>
<h3 id="raid01-01-raid10-10">RAID01 (0+1) / RAID10 (1+0)</h3>
<p>ストライピングされたディスクアレイをミラーリングするのが01、ミラーセットをストライプするのが10。</p>
<p>どちらも高速性と冗長性を確保するものであり、結果だけをみれば同じことになる。 だが、処理の仕方の順序が変わることで耐障害性に違いが出る。</p>
<p>例えば10台のディスクがあり、2レッグミラーを構成するとすると、 RAID01の場合、ストライピングされた5台のA群をミラーしたB群が生成される。 RAID10の場合、2レッグで構成されたミラーセットが5つあり、ミラーリングされた論理5ディスクをストライピングする。</p>
<p>RAID0が破壊される条件は、ディスクアレイのいずれかのディスクが破壊されたときである。 だから、RAID01の場合、A群から1台、B群から1台故障が出るとデータは失われる。</p>
<p>一方、RAID10の場合は、ミラーが消失する条件は同一ミラーの全レッグが消失したときであるため、「特定の2台」が故障したときにデータが失われる。</p>
<p>最小で障害になる台数はどちらも2だが、RAID01の場合は2台目の故障するディスクのうち致命的なのは5/9だが、RAID10の場合は2台目に故障するディスクで致命的なのは1/9である。 だから、RAID10のほうが固い。</p>
<h3 id="raid5">RAID5</h3>
<p>基本的にはRAID0と同じだが、全部の台数にストライプするわけではなく、1台はパリティというビットxorの情報を記録する。 これは、各ディスクのそのビットの和が奇数なら0を、偶数なら1を記録するということである。</p>
<p>RAID4は専用のディスクに対してパリティを記録していくが、RAID5はパリティをストライプごとにずらしていく「水平パリティ」を採用している。 こうなっている理由は、例えばRAID4でディスクが4台だとすると、パリティが記録される4台目のディスクは他の3台の書き込み時すべてに書き込みが発生し、要は3倍書くことになるので早く死ぬ。 さらに、このディスクには常にアクセスしなければならないことからディスクが増えても速くならない。</p>
<p>RAID5はディスク帯域的にはディスク台数から1台引いた分のRAID0並の速度が出る。それでいながら冗長性も確保できる。 使い勝手が良いように思えるが、以外と難しい。</p>
<p>一番の問題は、パリティの計算が重いということである。 このため、ディスクの交換やディスクの追加は非常に大変な作業になる。 特にディスクの追加は、全域に渡って配置し直して計算し直すという作業になるため、故障を引き起こすことも多い。</p>
<p>ついでに言えば、計算が常に重く、これが速度低下の原因になることもある。 特にソフトウェアRAIDの場合はディスクアクセス時にCPUが重いという状況を発生させる。</p>
<p>RAID5は常に1台の冗長性を確保する。2台目が故障すると必ず全体がfailする。 ただし、RAID5で1台故障したとき、残りのディスク故障確率はRAID0と同じであり、ディスクが1台死ぬときは同時に導入された他のディスクも瀕死だったりするため、 「RAID5の障害でディスクを救出していたら他のディスクが死んでだめになった」ということが、割と現実的に起きる。</p>
<h3 id="raid6">RAID6</h3>
<p>RAID6はRAID5からパリティを2つに増やした方式。 冗長性が2台に増えている。3台目の故障でfailする。</p>
<p>耐障害性が高く、ディスク数が多い場合は有力だが、ソフトウェアRAIDの場合はRAID5よりもさらに重い。</p>
<h3 id="raid56のraid構成">RAID5/6のRAID構成</h3>
<p>RAID10のように、RAID5やRAID6のディスクアレイをRIADの構成要素にすることもできることはできるけれど、一般的にはあまり見ない。</p>
<h3 id="raidの弱点">RAIDの弱点</h3>
<p>RAIDコントローラという、RAIDを構成するための機能が死ぬと全体が終わってしまう。 復元できないということではないが、稼働はできない。</p>
<p>ソフトウェアRAIDはこの点は安心である。</p>
<h2 id="jbod">JBOD</h2>
<p>単純にディスクを連結し、1台目のディスクがいっぱいになったら2台目のディスクに書いていく。</p>
<p>耐障害性は、使用されているディスクの範囲でRAID0と同じ。 RAID0のように速度が速くなるメリットはないが、RAIDが普通、「同一容量のディスクを要求し、容量が異なる場合は最小のディスクに揃えられる」ものであるのに対し、JBODはただ頭からいっぱいにしていくだけなので全部のディスクを使い切れる。</p>
<p>LinuxのLVMのリニアボリュームや、WindowsのダイナミックディスクのスパンボリュームもソフトウェアJBOD。</p>
<h2 id="btrfs-mirror">Btrfs Mirror</h2>
<p>Btrfsのミラーリング(RAID1)はちょっと変わっていて、同一容量のディスクを要求しない。 つまり、3TB+1.5TB+1.5TBのディスク構成で、「3TBの2レッグミラー」ができる。</p>
<p>ただし、3TB+1TB+1TBだと2TBしか書けない。</p>
<h2 id="raid-z">RAID-Z</h2>
<p>ZFSに備わっているソフトウェアRAID。</p>
<p>パリティ更新に失敗してデータが壊れる、という問題を回避する機能が載っている。 基本的にはRAID5/6の改良版。</p>
<h2 id="ホットスペア">ホットスペア</h2>
<p>ストレージサーバーなんかに載せられるようになっている、普段は使っていないディスク。</p>
<p>RAIDディスク故障時にすぐに交換したのと同じ状況が得られるようになっている。 RAID5の場合はRAID6と同じようなものなので、どちらかといえばRAID6を構成することを想定しているのが一般的。</p>
<p>ディスク交換と稼働を切り離せるのでディスク交換作業が楽になる、という面が大きい。</p>
<h2 id="ファイルディストリビュート">ファイルディストリビュート</h2>
<p>GlusterFSなんかに載っている機能。 複数のディスクに分散してファイルを置く。</p>
<p>同時にいろんなファイルにアクセスするとRAID0のようにアクセスが分散されて高速化する。 そんなに大きくないデータでもうまいことシーケンシャルになって速くなったりする。</p>
<p>また、ディスクが1台死んだときに失われるデータが全部ではなくて、そのディスク上のデータだけになる。</p>
<p>GlusterFSで手軽な拡張を目論んでいる場合は、拡張が楽ということでディストリビュートを使うことが多い。 冗長性は上がらないので、RAID1やRAID5と組み合わせて使う。</p>
<p>ちなみに、GlusterFSは自前でRAID0なブロックストライピングと、同様のRAID5を持っている。</p>
<h2 id="ファイルレプリケート">ファイルレプリケート</h2>
<p>同一ファイルを複数のディスクに書く、RAID1のファイル単位版。 GlusterFSでベース単位がファイルになっている環境でreplicatedだとこれになる。</p>
<p>バックアップに近いものなので、非常に扱いやすい。ただ、これができる環境が限られるのと、性能向上にはつながらない。 基本的にはソフトウェア的に実装されるもので、OS的には倍書き込みを発生させるわけで、むしろ遅くなる。</p>
<h2 id="バックアップとどう違うの">バックアップとどう違うの?</h2>
<p>冗長性っていうのは、止めない、失わないこと重視。</p>
<p>バックアップは、失ったときに復活させるもの。</p>
<p>別物だし、両方必要。 私の環境は、RAID5のreplicatedなので、1台冗長の構成でバックアップがひとつ。</p>

<!-- PBSEARCH_RESULT -->
        </article>
    </section>
    <footer id="InfoFooter">
      <ul>
        <li>© Masaki Haruka 2003.</li>
        <li>Generated by <a href="https://gitlab.com/reasonset/pbsimply-wpimporter">PureBuilder Simply WP Importer</a></li>
      </ul>
    </footer>
  </body>
</html>
