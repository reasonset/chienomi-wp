<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja" xml:lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="PureBuilder Simply WP Importer" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
    <meta name="author" content="Masaki Haruka" />
    <meta name="date" content="2019-02-01T00:00:00+09:00" />
    <meta name="dcterms.date" content="2019-02-01T00:00:00+09:00" />
    <title>宅ふぁいる便の個人情報漏洩、一般向けに軽く解説 - Chienomi</title>
    <style type="text/css">article {
max-width: 1080px;
margin: auto;
}</style>
  </head>
  <body>

    <section id="ContentContainer">
      <header id="MainHeader"><a href="/"><h1>Chienomi</h1></a></header>
      <section id="ArticleBox">
        <header id="ArticleTitle"><h1>宅ふぁいる便の個人情報漏洩、一般向けに軽く解説</h1></header>
        <article id="MainArticle">
<h2 id="序">序</h2>
<p>480万件という数字から「国内史上最悪」とも言われる個人情報漏洩事件だが、問題がいまひとつわからないという人もいるかもしれない。過去には「500円配布で済ませた」という案件もあったからだ。</p>
<p>特に問題である点を軽く解説しよう。</p>
<h2 id="パスワードの暗号化">「パスワードの暗号化」</h2>
<p>お知らせメールに「パスワードを暗号化していませんでした」という記述があり、これが問題の中心になっている。</p>
<p>まず、「暗号化」という言葉にいささかの問題をはらんでいる。 暗号化が意味するところ、というのは難しい話になるのだが、コンピュータの文脈においては普通は特定の条件下でのみ元に戻せる(復号化できる)ものを暗号化という場合が多い。 暗号化を行うメソッドが暗号であり、暗号を暗号たらしめるのが暗号鍵だ。</p>
<p>ここでいう「暗号化」はこのような暗号の話ではなく、一方向関数の話である。</p>
<p>一方向関数(ハッシュ関数)はAという値からBという値を算出することができるが、Bという値からAという値は算出できない関数である。</p>
<p>一方向関数で有名なのはMD5である。例えば<code>password</code>という文字列をMD5にかけると<code>286755fad04869ca523320acce0dc6a4</code>という値が得られる。 だが、この得られた値から<code>password</code>という文字列を得ることはできない。</p>
<p>サービス側ではユーザーのパスワードをデータベース上に保存するのだが、これを平文のパスワードに代えてハッシュ化された値を保存しておく。実際に認証する際にはユーザーはもちろん平文のパスワードを送信するのだが、サービス側で認証する際にハッシュ化してからハッシュ化して保存してある値と一致するかをチェックするのである。</p>
<p>なんのためか、というと、「パスワードそのものを持っている状態にしないため」だ。</p>
<p>その節の以下は付加知識で、次の節まで飛ばしてもらっても構わない。</p>
<p>まず、MD5に関しては「ハッシュ化した結果を同一にする手法」が見つかっており、パスワードにおいては「正しくないパスワードで突破されてしまう」リスクがあり、不十分なものとなっている。 現在十分とされているのはSHA256だ。SHA256で<code>password</code>をハッシュ化すると<code>6b3a55e0261b0304143f805a24924d0c1c44524821305f31d9277843b8a10f4e</code>が得られる。</p>
<p>また、単にハッシュ化しただけでは、一発で特定されるわけではないものの、複数の(同一ユーザーの)パスワードリストを手に入れたときに、「同じパスワードを使っている」ということは一発でわかってしまい、かつ法則性などを推測して突破するのも可能性として生まれてくる。</p>
<p>そのため、基本的には“salt”と呼ばれる値を付加してハッシュ化する。 例えばsaltとして<code>C</code>を使い、<code>passwordC</code>としてからハッシュ化するとSHA256では<code>57f99e20c1e9f0f7355c3afd44715bda1dc0bd01db08509c4026c56d63bced3d</code>となり、全く異なる値が得られる。 こうすることでより安全にすることができる。</p>
<h2 id="その必要性">その必要性</h2>
<p>なぜパスワードそのものを持っているといけないのだろうか。</p>
<p>答は、「パスワードが保存されているデータベースを見るのはかなり簡単である」ということがある。 もちろん、漏洩時のリスクを低減するというのもあるが、「内部犯による流出、あるいは悪用」を防ぐという意味もある。</p>
<p>また、第一に漏洩したときに平文で保存されていると、漏洩した情報を手に入れた人は直ちに不正利用可能な状態になってしまう。 ハッシュ化されているとなんらかの突破口を見つけて解き明かさないと不正利用できない。</p>
<p>また、あなたはすべてのサービスでパスワードを異なるものを使っているだろうか? 恐らくそんなことをしているのはセキュリティの専門家くらいのものだろう(私はやっているけれども)。 だから、平文で保存されていると他のサービスまで巻き込んで大きな被害が出やすい。</p>
<p>絶対に漏洩しないようにする、というのは多人数が関わるシステムでは現実的に不可能である。 そのため、「もし漏洩したとしてもなるべく被害が小さいように設計しなければならない」のであり、480万件もの個人情報を扱いながらそのような意識を持っていなかったことが批判されているのだ。</p>
<h2 id="それだけでは終わらない">それだけでは終わらない</h2>
<p>メールで「漏洩があったのでパスワードを変更するように」と呼びかけていながら、システムをロックし、パスワードが変更できないようにしているという矛盾した対応にも批判が集まっている。</p>
<p>また、「不正利用を確認していない」というが、実際不正アクセスがあったとして、それが「宅ふぁいる便のユーザー情報 に由来して発生したものか」ということを検証するのは極めて難しく、そもそも検証しようにも誰もがそのデータを入手できるわけではないから、宅ふぁいる便が拒否して否定すればそれ以上は追求しようがない。</p>
<p>だから、「不正利用を確認していない」という発表は何の役にも立たない。</p>
<p>これはそういう問題である。</p>
<h2 id="本人だけの影響ではない">本人だけの影響ではない</h2>
<p>「そのサービスは使っていないから自分は関係ない」と考えるのは早計だ。</p>
<p>不正ログインの試行において使用するパスワードは、まず過去に使われたことのあるパスワードを使うリスト型攻撃が鉄板である。 さらにいえば、使われたことのあるパスワードがわかっていれば、AI流行りの今の御時世、「法則から人がつけそうなパスワードを類推して試みる」のがいかに容易かというのは想像に固くないだろう。</p>
<p>つまり、パスワードの流出は悪意ある攻撃者の辞書を分厚くし、関係ない人のパスワードが破られる可能性も向上するのである。</p>

<!-- PBSEARCH_RESULT -->
        </article>
    </section>
    <footer id="InfoFooter">
      <ul>
        <li>© Masaki Haruka 2003.</li>
        <li>Generated by <a href="https://gitlab.com/reasonset/pbsimply-wpimporter">PureBuilder Simply WP Importer</a></li>
      </ul>
    </footer>
  </body>
</html>
